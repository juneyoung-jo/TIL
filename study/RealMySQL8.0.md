# 05 트랜잭션과 잠금

- 잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기위한 기능이다.
- 트랜잭션
  - 논리적인 작업 셋 자체가 100% 적용되거(commit)나 아무것도 적용되지 않아야함(rollback)을 보장해 주는 것
  - 프로그램 코드에서 트랜잭션 범위를 최소화 해야 함. (db 서버가 높은 부하 상태로 빠지거나 위험한 상태에 빠질경우가 빈번히 발생함.)
- MySQL 엔진의 잠금
  - 글로벌 락
    - FLUSH TABLES WITH READ LOCK 명령으로 획득
    - 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT 를 제외한 대부붕늬 DDL 문장이나 DML 문장을 실행하는 경우 대기상태
    - MyISAM 이나 MEMORY 테이블에 대해 mysqldump로 일관된 백업을 받아야할 때 사용
  - 테이블 락
  - 네임드 락
  - 메타데이터 락
    - 데이터베이스 객체(테이블이나 뷰 등)의 이름이나 구조를 변경하는 경우 획득하는 잠금
- InnoDB 스토리지 엔진 잠금
  - 스토리지 엔진 내부에서 레코드 기반 잠금 방식을 탑재하고 있음.
  - 레코드 락
    - 인덱스의 레코드를 잠근다.
  - 갭 락
  - 넥스트 키 락
  - 자동 증가 락
    - AUTO_INCREMENT 락 이라고 하는 테이블 수준의 잠금을 사용하여 채번 함.
- 인덱스와 잠금
  - 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리됨.
  - update 문장을 위해 적절한 인덱스 설정이 필요함.
    - 변경해야 할 문장을 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 함.
- MySQL 격리 수준
  - SERIALIZABLE 격리 수준이 아니라면 크게 성능의 개선이나 저하는 발생하지 않음.
  - READ UNCOMMITTED
    - dirty read, non_repeatable read, phantom read
      - dirty read: 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상
      - non_repeatable read: 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 한다에 반하는 현상
      - phantom read: 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안보였다 하는 현상 (select for update 같은 쿼리는 레코드에 쓰기 잠금을 걸어야 하는데 언두 레코드에는 잠금을 걸 수 없어 현재 레코드의 값을 가져오게됨. 따라서 팬텀 리드 현상이 있음.)
  - READ COMMITTED
    - non_repeatable read, phantom read
  - REPEATABLE READ
    - phantom read (innoDB는 phantom read 현상 없음.=> 갭락과 넥스트 키 락 덕분)
  - SERIALIZABLE
    - x

# 08 인덱스

- 인덱스란
  - SortedList 와 마찬가지로 저장되는 칼럼의 값을 이용해 항상 정렬된 상태를 유지한다 (key-value 쌍으로 저장)
  - 선택도(Selectivity) 또는 기수성(Cardinality)가 높아야 성능이 좋다.
  - 카드널리티가 좋지 않다고 하더라도 정렬이나 그루핑과 같은 작업을 위해 인덱스를 만드는 것이 훨씬 나은 경우도 있다.
  - 옵티마이저가 판단한 예상 건수가 전체 테이블 레코드의 20~25%를 넘어가면 인덱스를 이용하지 않는게 효율적임
- 인덱스 레인지 스캔
  - 인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.
  - 일단 시작해야 할 위치를 찾으면(인덱스 탐색 index seek) 그때부터는 리프 노드의 레코드만 순서대로 읽는다(인덱스 스캔 index scan), 최종적으로 스캔을 멈춰야 할 위치에 다다르면 지금까지 읽은 레코드를 사용자에게 반환하고 쿼리를 끝낸다.

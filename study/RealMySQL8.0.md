# 05 트랜잭션과 잠금

- 잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기위한 기능이다.
- 트랜잭션
  - 논리적인 작업 셋 자체가 100% 적용되거(commit)나 아무것도 적용되지 않아야함(rollback)을 보장해 주는 것
  - 프로그램 코드에서 트랜잭션 범위를 최소화 해야 함. (db 서버가 높은 부하 상태로 빠지거나 위험한 상태에 빠질경우가 빈번히 발생함.)
- MySQL 엔진의 잠금
  - 글로벌 락
    - FLUSH TABLES WITH READ LOCK 명령으로 획득
    - 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT 를 제외한 대부붕늬 DDL 문장이나 DML 문장을 실행하는 경우 대기상태
    - MyISAM 이나 MEMORY 테이블에 대해 mysqldump로 일관된 백업을 받아야할 때 사용
  - 테이블 락
  - 네임드 락
  - 메타데이터 락
    - 데이터베이스 객체(테이블이나 뷰 등)의 이름이나 구조를 변경하는 경우 획득하는 잠금
- InnoDB 스토리지 엔진 잠금
  - 스토리지 엔진 내부에서 레코드 기반 잠금 방식을 탑재하고 있음.
  - 레코드 락
    - 인덱스의 레코드를 잠근다.
  - 갭 락
  - 넥스트 키 락
  - 자동 증가 락
    - AUTO_INCREMENT 락 이라고 하는 테이블 수준의 잠금을 사용하여 채번 함.
- 인덱스와 잠금
  - 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리됨.
  - update 문장을 위해 적절한 인덱스 설정이 필요함.
    - 변경해야 할 문장을 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 함.
- MySQL 격리 수준
  - SERIALIZABLE 격리 수준이 아니라면 크게 성능의 개선이나 저하는 발생하지 않음.
  - READ UNCOMMITTED
    - dirty read, non_repeatable read, phantom read
      - dirty read: 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상
      - non_repeatable read: 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 한다에 반하는 현상
      - phantom read: 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안보였다 하는 현상 (select for update 같은 쿼리는 레코드에 쓰기 잠금을 걸어야 하는데 언두 레코드에는 잠금을 걸 수 없어 현재 레코드의 값을 가져오게됨. 따라서 팬텀 리드 현상이 있음.)
  - READ COMMITTED
    - non_repeatable read, phantom read
  - REPEATABLE READ
    - phantom read (innoDB는 phantom read 현상 없음.=> 갭락과 넥스트 키 락 덕분)
  - SERIALIZABLE
    - x

# 08 인덱스

- 인덱스란
  - SortedList 와 마찬가지로 저장되는 칼럼의 값을 이용해 항상 정렬된 상태를 유지한다 (key-value 쌍으로 저장)
  - 선택도(Selectivity) 또는 기수성(Cardinality)가 높아야 성능이 좋다.
  - 카드널리티가 좋지 않다고 하더라도 정렬이나 그루핑과 같은 작업을 위해 인덱스를 만드는 것이 훨씬 나은 경우도 있다.
  - 옵티마이저가 판단한 예상 건수가 전체 테이블 레코드의 20~25%를 넘어가면 인덱스를 이용하지 않는게 효율적임
- 인덱스 레인지 스캔
  - 인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.
  - 일단 시작해야 할 위치를 찾으면(인덱스 탐색 index seek) 그때부터는 리프 노드의 레코드만 순서대로 읽는다(인덱스 스캔 index scan), 최종적으로 스캔을 멈춰야 할 위치에 다다르면 지금까지 읽은 레코드를 사용자에게 반환하고 쿼리를 끝낸다.
- 인덱스 풀 스캔
  - 인덱스의 처음부터 끝까지 모두 읽는 방식
  - ex) 인덱스를 (A,B,C) 순서로 만들었지만 쿼리의 조건절은 B or C 칼럼으로 검색하는 경우
- 루즈 인덱스 스캔
  - 느슨하게, 듬성듬성 인덱스를 읽는 방법, 중간에 필요치 않은 인덱스 키 값은 무시(SKIP)
  - 일반적으로 GROUP BY 또는 집합 함수 가운데 max, min 함수에 대해 최적화를 하는 경우에 사용됨.
- 인덱스 스킵 스캔
  - (gender, birth_date) 인덱스를 생성했을 때 where 조건에 birth_date 칼럼만으로도 인덱스 검색이 가능하게 해주는 방법
  - 단점
    - WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함.
    - 쿼리가 인덱스에 존재하는 컬럼만으로 처리 가능해야 함(커버링 인덱스)
- B-Tree 인덱스의 가용성과 효율성
  - 비교 조건의 종류와 효율성
    - 공식적인 명칭은 아니지만 '작업 범위를 결정하는 조건', '필터링 조건' 이 있다.
    - '작업 범위를 결정하는 조건'이 많을수록 성능이 높다
    - '필터링 조건'은 쿼리의 성능을 높이지는 못한다. 오히려 낮출 수 있음.
  - 가용성과 효율성 판단
    - 작업 범위 결정 조건으로 사용할 수 없는 경우
      - NOT-EQUAL 로 비교된 경우 ("<>", "NOT_IN", "NOT BETWEEN", "IS NOT NULL")
      - LIKE '%??' 형태의 패턴
      - 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교되는 경우
        - ... WHERE SUBSTRING(column,1,1) = 'X'
        - ... WHERE DAYOFMONTH(column) = 1
      - NOT-DETERMINISTIC 속성의 스토어드 함수가 비교조건에 사용된 경우
        - ... WHERE column = deterministic_function()
      - 데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)
        - ... WHERE char_column = 10
      - 문자열 데이터 타입의 콜레이션이 다른 경우
- 클러스터링 인덱스
  - 테이블의 프라이머리 키에 대해서만 적용되는 내용임. 즉, 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것
  - 장점
    - 프라이머리 키로 검색할 때 처리 성능이 매우 빠름
    - 테이블의 모든 세컨더리 인덱스가 프라이커리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음(커버링 인덱스)
  - 단점
    - 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
    - 세컨더리 인게스를 통해 검색할 때 프라이커리 키로 다시 한번 검색해야 하므로 처리 성능이 느림
    - INSERT 할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 떄문에 처리 성능이 느림
    - 프라이머리 키를 변경할 때 레코드를 DELETE하고 INSERT하는 작업이 필요하기 때문에 처리 성능이 느림
  - 일반적인 웹서비스와 같은 온라인 트랜잭션 환경(OTLP)환경에서는 읽기 비율이 높기 때문에 조금 느린 쓰기를 감수하고 사용함.
  - 프라이머리 키는 AUTO-INCREMENT 보다는 업무적인 칼럼으로 생성(가능한 경우에만)
  - 프라이머리 키를 반드시 명시할 것
- 유니크 인덱스
  - 유니크 인덱스와 일반 세컨더리 인덱스는 사실 인덱스 구조상 아무런 차이점이 없다.
  - 유니크 인덱스가 세컨더리 인덱스보다 더 빠른것은 아니다. (성능상 큰 차이 없음)
  - 인덱스 쓰기의 경우 중복 체크를 해야 하므로 더 느리다.
  - 꼭 필요한 경우가 아니라면 불필요하게 생성하지 않는 것이 좋다.

# 09 옵티마이저와 힌트

- 풀 테이블 스캔과 풀 인덱스 스캔
  - 다음과 같은 조건일 경우 옵티마이저가 풀 테이블 스캔을 선택한다
    - 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우
  - WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
  - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
- ORDER BY 처리(Using filesort)
  - 레코드 대상 건수가 많아질수록 쿼리의 응답속도가 느리다.
- 정렬 처리 방법
  - 실행 계획의 Extra 칼럼의 내용
    - 1. 인덱스를 사용한 정렬: 별도 표기 없음.
    - 2. 조인에서 드라이빙 테이블만 정렬: "Using filesort"
    - 3. 조인에서 조인 결과를 임시 테이블로 저장 후 정렬: "Using temporary; Using filesort"

# 10 실행 계획

- 실행 계획 확인
  - DESC, EXPLAIN 명령어로 실행계획을 확인할 수 있다.
  - EXPLAIN ANALYZE 기능으로 쿼리의 실행 계획과 단계별 소요된 시간 정보를 확인할 수 있다.
    - 들여쓰기가 같은 레벨에서는 상단에 위치한 라인이 먼저 실행
    - 들여쓰기가 다른 레벨에서는 가장 안족에 위치한 라인이 먼저 실행
    - actual_time(실제 소요된 시간), rows(처리한 레코드 건수), loops(반복 횟수)가 표기
- 실행 계획 분석
  - id 칼럼
    - 단위 SELECT 쿼리별로 부여되는 식별자 값
    - 테이블의 접근순서를 의미하지는 않음
  - select_type 칼럼
    - 각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시됨
    - SIMPLE
      - UNION이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우
    - PRIMARY
      - UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행계획에서 가장 바깥쪽에 있는 쿼리
    - UNION
      - UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리
      - UNION의 첫 번째 단위 SELECT는 DERIVED(임시테이블)로 표시된다.
    - DEPENDENT UNION
    - UNION RESULT
    - SUBQUERY
      - from 절 이외에서 사용되는 서브쿼리
    - DEPENDENT SUBQUERY
    - DERIVED
    - DEPENDENT DERIVED
    - UNCACHEABLE SUBQUERY
    - UNCACHEABLE UNION
    - MATERIALIZED
  - table 칼럼
    - 테이블의 이름 or 별칭이 표기됨.
  - type 칼럼
    - mysql 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타냄
    - system
      - 레코드가 1건만 존재하는 테이블 or 한 건도 존재하지 않는 테이블을 참조하는 형태
    - const
      - 쿼리가 프라이머리 키나 유니크 키 칼럼을 이요하는 WHERE 조건절을 가지고 있으며 반드시 1건을 반환하는 쿼리의 처리 방식
    - eq_ref
      - 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시
      - 조인에서 처음 읽은 테이블의 컬럼값을 그다음 읽어야 할테이블의 프라이머리 키나 유니크 키 칼럼의 검색 조건에 사용할 경우
    - ref
      - 조인의 순서와 관계없이 사용되며, 프라이머리 키나 유니크 키 등의 제약조건도 없다.
      - 인덱스의 종류와 관계없이 동등(Equal) 조건으로 검색할 때 사용됨
    - fulltext
    - ref_or_null
      - ref 접근방식과 같은데 NULL 비교가 추가된 형태
      - 실무에 많이 활용되지는 않음, 나쁘지 않은 접근 방법 정도로 기억하면 됨.
    - unique_subquery
      - WHERE 조건절에서 사용될 수 있는 IN(subquery) 형태의 쿼리를 위한 접근 방식
      - 서브쿼리에서 중복되지 않는 유니크한 값만 반환할 때 이 접근방식을 사용
    - index_subquery
    - range
      - 익히 알고 있는 인덱스 레인지 스캔 형태의 접근 방식
      - 인덱스를 범위로 스캔하는 방식, 주로 "<, >, IS NULL, BETWEEN, IN, LIKE" 등의 연산자를 이용
      - 상당히 빠르며, 최적의 성능이 보장된다고 할 수 있다
    - index_merge
      - 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후, 그 결과를 병합해서 처리하는 방식
    - index
      - 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔
    - ALL
      - 인덱스를 사용하지 않는 접근 방법
      - 풀스캔
